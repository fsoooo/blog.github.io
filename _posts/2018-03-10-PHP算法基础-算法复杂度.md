---
layout: post
catalog: true
tags:
  - PHP
  - 算法
---
算法复杂度分为时间复杂度和空间复杂度。时间复杂度是指执行算法所需要的计算工作量； 而空间复杂度是指执行这个算法所需要的内存空间。 

算法的复杂性体现在运行该算法时的计算机所需资源的多少上，计算机资源最重要的是时间和空间（即寄存器）资源，因此复杂度分为时间和空间复杂度。

简单来说，时间复杂度指的是语句执行次数，空间复杂度指的是算法所占的存储空间

#### **时间复杂度** 

计算时间复杂度的方法：

1. 用常数1代替运行时间中的所有加法常数
2. 修改后的运行次数函数中，只保留最高阶项
3. 去除最高阶项的系数

按数量级递增排列，常见的时间复杂度有： 
常数阶`O(1)`,对数阶`O(log2n)`,`线性阶O(n)`, 
线性对数阶`O(nlog2n)`,平方阶`O(n^2)`，立方阶`O(n^3)`,…， 
k次方阶`O(n^k)`,指数阶`O(2^n)`。 
随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低。

举个栗子:

```
sum = n*(n+1)/2;        //时间复杂度O(1)
```

```
for(int i = 0; i < n; i++){
    printf("%d ",i);
}                       
//时间复杂度O(n)
```

```
for(int i = 0; i < n; i++){
    for(int j = 0; j < n; j++){
        printf("%d ",i);
    }
}               
//时间复杂度O(n^2)
```

```
for(int i = 0; i < n; i++){
    for(int j = i; j < n; j++){
        printf("%d ",i);
    }
}   
//运行次数为(1+n)*n/2
//时间复杂度O(n^2)
int i = 0, n = 100;
while(i < n){
    i = i * 2;
}
//设执行次数为x. 2^x = n 即x = log2n
//时间复杂度O(log2n)
```

**最坏时间复杂度和平均时间复杂度** 
　最坏情况下的时间复杂度称最坏时间复杂度。一般不特别说明，讨论的时间复杂度均是最坏情况下的时间复杂度。 
　这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的上界，这就保证了算法的运行时间不会比任何更长。 
　平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，算法的期望运行时间。设每种情况的出现的概率为pi,平均时间复杂度则为`sum(pi*f(n)) `。
　

**常用排序算法的时间复杂度**

| 排序方法     | 时间复杂度（平均） | 时间复杂度（最坏) | 时间复杂度（最好) | 空间复杂度 | 稳定性 | 复杂性 |
| ------------ | ------------------ | ----------------- | ----------------- | ---------- | ------ | ------ |
| 直接插入排序 | O(n2)              | O(n2)             | O(n)              | O(1)       | 稳定   | 简单   |
| 希尔排序     | O(nlog2n)          | O(n2)             | O(n)              | O(1)       | 不稳定 | 较复杂 |
| 直接选择排序 | O(n2)              | O(n2)             | O(n2)             | O(1)       | 不稳定 | 简单   |
| 堆排序       | O(nlog2n)          | O(nlog2n)         | O(nlog2n)         | O(1)       | 不稳定 | 较复杂 |
| 冒泡排序     | O(n2)              | O(n2)             | O(n)              | O(1)       | 稳定   | 简单   |
| 快速排序     | O(nlog2n)          | O(n2)             | O(nlog2n)         | O(nlog2n)  | 不稳定 | 较复杂 |
| 归并排序     | O(nlog2n)          | O(nlog2n)         | O(nlog2n)         | O(n)       | 稳定   | 较复杂 |
| 基数排序     | O(d(n+r))          | O(d(n+r))         | O(d(n+r))         | O(n+r)     | 稳定   | 较复杂 |

##### 常见查找算法时间复杂度

| 查找                 | 平均时间复杂度 | 查找条件               | 算法描述                                                     |
| -------------------- | -------------- | ---------------------- | ------------------------------------------------------------ |
| 顺序查找             | O(n)           | 无序或有序队列         | 按顺序比较每个元素，直到找到关键字为止                       |
| 二分查找（折半查找） | O(logn)        | 有序数组               | 查找过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜素过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。　如果在某一步骤数组为空，则代表找不到。 |
| 二叉排序树查找       | O(logn)        | 二叉排序树             | 在二叉查找树b中查找x的过程为：1. 若b是空树，则搜索失败2. 若x等于b的根节点的数据域之值，则查找成功；3. 若x小于b的根节点的数据域之值，则搜索左子树4. 查找右子树。 |
| 哈希表法（散列表）   | O(1)           | 先创建哈希表（散列表） | 根据键值方式(Key value)进行查找，通过散列函数，定位数据元素。 |
| 分块查找             | O(logn)        | 无序或有序队列         | 将n个数据元素"按块有序"划分为m块（m ≤ n）。每一块中的结点不必有序，但块与块之间必须"按块有序"；即第1块中任一元素的关键字都必须小于第2块中任一元素的关键字；而第2块中任一元素又都必须小于第3块中的任一元素，……。然后使用二分查找及顺序查找。 |

#### **空间复杂度** 

空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度，记做 `S(n)=O(f(n))`。

对于一个算法来说，**空间复杂度和时间复杂度往往是相互影响的**。

当追求一个较好的时间复杂度时，可能会使空间复杂度的性能变差，即可能导致占用较多的存储空间；反之，当追求一个较好的空间复杂度时，可能会使时间复杂度的性能变差，即可能导致占用较长的运行时间。

有时我们可以用空间来换取时间以达到目的。
