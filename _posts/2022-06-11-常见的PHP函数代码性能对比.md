日常开发中，我们通常会使用常规的、显而易见的 PHP 函数来解决相应的问题。

但是这些方便的内置函数真的高效吗？有没有更高效的替代解决方案？

![](https://upload-images.jianshu.io/upload_images/6943526-645b23a0f1ea8f2b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


现在，来介绍其中的一些替代方案。

如果你正在寻找在生产中进一步减少执行时间的可能性，这将非常有用。

让我们来看看哪些 PHP 方法可能会被性能更好的方法取代，以及是否有任何成本或权衡。

**所有这些方法都在本地 Web 服务器上使用 PHP 7.4 进行了测试。**

**1\. 删除重复项**

你有一个包含重复项的大型数组，并且希望删除它们，以便只有一个具有唯一值的数组。

 常规


```
array_unique($array);
```

 其他方式


```
array_keys(array_flip($array));
```

####性能

创建了一个 400 万的数组，其中有 300 万个重复项，这是最好的优化结果:

方法执行时间

| 方法                    | 执行时间      |
| --------------------- | --------- |
| array_unique          | 787.31 ms |
| array_keys array_flip | 434.03 ms |

其他方式比常规方式 快了 1.8 倍 (44.87%) . 平均也有大约 1.5 倍 (30%) 的提升。

>#####总结：这仅适用于一维数组，因为 array_flip 会反转键和值.

**2. 获取随机的数组元素**

你想从一个大数组中获取一个随机值

常规


```
array_rand($array);
```

其他方式


```
$array[mt_rand(0, count($array) - 1)];
```

#### 性能

我创建了一个包含 500 万个元素的数组，这是最佳结果:

方法执行时间

| 方法         | 执行时间     |
| ---------- | -------- |
| array_rand | 25.99 μs |
| mt_rand    | 0.95 μs  |

替代方法在此测量中快 27.3 倍 (96.33%)。平均快 8 倍 (87%)。这个结果特别令人惊讶，因为 mt_rand 是 Mersenne Twister 随机数生成器的实现，而且从 PHP7.1 开始，内部随机化算法已更改为使用完全相同的算法。

**3. 字母数字字符测试**

如果你有一个字符串，并且希望测试它是否只包含字母数字字符。

常规


```
preg_match('/[a-zA-Z0-9]+/', $string);
```

其他方式


```
ctype_alnum($string);
```

####性能

创建了一个包含超过 100k 字母数字和非字母数字字符串的数组。以下是排名靠前的结果：

| methodexecution | time     |
| --------------- | -------- |
| preg_match      | 15.39 ms |
| ctype_alnum     | 2.06 ms  |

替代方法在此测量中快 7.5 倍 (86.59%)。平均而言，它快了约 4 倍 (76%)。

同样的道理也可以应用于 ctype_alpha() 命令 (检查字母字符) 和 ctype_digit() 命令 (检查数字字符)。

**4. 替换子字符串**

你有一个字符串，并且希望用另一个子字符串替换它的一部分。

 常规


```
str_replace('a', 'b', $string);
```

 其他方式


```
strtr($string, 'a', 'b');
```

####性能

创建了一个包含 500 万个随机字符串的数组。以下是排名靠前的结果：

| methodexecution | time      |
| --------------- | --------- |
| str_replace     | 676.59 ms |
| strtr           | 305.59 ms |

替代方法在此测量中快 2.2 倍 (54.83%)。平均快 2 倍 (51%)。

**额外的性能改进**

以下是我在编码约定中搜集的一些附加方法，我发现它们可以略微提高性能 (如果适用)：

- 更喜欢 JSON 而不是 XML
- 在之前声明变量，而不是在循环的每次迭代中声明变量
- 避免循环头部中的函数调用 `(在每次迭代中调用的 for ($i=0; $i<count($array); $i) 中的 count() 中)`
- 注销消耗内存变量
- 首选` select 语句而不是多个 if 语句`
- 优先选择` require/include 而不是 require_once/include_once (确保正确的操作码缓存）`

最后一句话：我知道关于过早优化的讨论。我同意，生产中的性能取决于诸如数据库查询之类的瓶颈，在处理性能时应该重点关注这些瓶颈。但我认为，如果有更快的替代方案，例如，在 regex 更容易处理和维护的情况下，为什么不使用它们呢？

**总结**

我们已经看到，即使使用当前的 PHP 7.4 (已经比以前的 PHP 版本快得多)，也有可能使用其他方法进一步提高脚本性能。

![](https://upload-images.jianshu.io/upload_images/6943526-470af65c646f460a.gif?imageMogr2/auto-orient/strip)
